/*
SQLyog Ultimate v12.08 (64 bit)
MySQL - 5.7.19 : Database - blog_springboot_vue
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`blog_springboot_vue` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `blog_springboot_vue`;

/*Table structure for table `blog` */

DROP TABLE IF EXISTS `blog`;

CREATE TABLE `blog` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `title` varchar(100) NOT NULL DEFAULT '0' COMMENT '文章标题',
  `summary` text COMMENT '摘要',
  `content` mediumtext COMMENT '文章全文',
  `user_id` int(10) NOT NULL DEFAULT '1' COMMENT '哪个用户的文章',
  `audit` int(4) NOT NULL DEFAULT '1' COMMENT '审核状态:0(通过)、1(未通过)、2(未审核)',
  `like` int(10) NOT NULL DEFAULT '0' COMMENT '点赞数，可多次点赞',
  `release_time` varchar(50) DEFAULT '0' COMMENT '发布时间',
  `mtime` varchar(50) NOT NULL DEFAULT '0' COMMENT '修改时间',
  `browse` int(10) NOT NULL DEFAULT '0' COMMENT '浏览量',
  `top` int(4) NOT NULL DEFAULT '1' COMMENT '0：置顶，1：不置顶',
  `tag` varchar(100) DEFAULT '0' COMMENT '文章标签，逗号分隔',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=42 DEFAULT CHARSET=utf8;

/*Data for the table `blog` */

insert  into `blog`(`id`,`title`,`summary`,`content`,`user_id`,`audit`,`like`,`release_time`,`mtime`,`browse`,`top`,`tag`) values (1,'书单',' 读书使人得到一种优雅和风味，这就是读书的整个目的，而只有抱着这种目的的读书才可以叫做艺术。一人读书的目的并不是要“改进心智”，因为当他开始想要改进心智的时候，一切读书的乐趣便丧失净尽了。',' 读书使人得到一种优雅和风味，这就是读书的整个目的，而只有抱着这种目的的读书才可以叫做艺术。一人读书的目的并不是要“改进心智”，因为当他开始想要改进心智的时候，一切读书的乐趣便丧失净尽了。',1,0,85,'2019-01-21','0',9954,0,'书单'),(2,'多态到底有什么用？','结论：多态可有可无但又至关重要，在不考虑代码今后的发展时，多态是无用的，如果考虑以后代码的修改与增删，多态是能大大提高代码的扩展性与复用的。想搞清楚有什么用之前，先说说什么是多态：多态可以理解为一个事物可以拥有多种形态（自己理解的，后面会讲为啥）规范定义：1.需要有\r\n阅读全文 »','结论：多态可有可无但又至关重要，在不考虑代码今后的发展时，多态是无用的，如果考虑以后代码的修改与增删，多态是能大大提高代码的扩展性与复用的。想搞清楚有什么用之前，先说说什么是多态：多态可以理解为一个事物可以拥有多种形态（自己理解的，后面会讲为啥）规范定义：1.需要有\r\n阅读全文 »',1,0,100,'2022-11-17','0',170,1,'java'),(3,'这是前端传入的','这是前端传入的这是前端传入的','这是前端传入的这是前端传入的这是前端传入的',1,0,99,NULL,'',33333,0,'前端传入'),(5,'这是前端传入的','这是前端传入的这是前端传入的','这是前端传入的这是前端传入的这是前端传入的',1,1,99,'2022-11-24T17:26:24.376Z','',33333,0,'前端传入'),(6,'这是前端传入的','这是前端传入的这是前端传入的','这是前端传入的这是前端传入的这是前端传入的',1,0,99,'2022-11-24T17:26:25.889Z','',33333,0,'前端传入'),(7,'这是前端传入的','这是前端传入的这是前端传入的','这是前端传入的这是前端传入的这是前端传入的',1,1,99,'2022-11-24T17:26:28.224Z','',33333,0,'前端传入'),(8,'这是前端传入的','这是前端传入的这是前端传入的','这是前端传入的这是前端传入的这是前端传入的',1,1,99,'2022-11-24T17:29:54.141Z','',33333,1,'前端传入'),(10,'进制间转换','十、二、八、十六进制间转换（包含负数间进制转换）原码、补码、反码定义我们知道 1字节 (byte) = 8 位(bit)（即8位二进制，如：11111111）、1024个字节 = 1 K 、1024 K = 1M  ​		所以，一字节可以表示的范围就有 0 ~ 256 （无符号数），而有符号数表示的范围则是： -128 ~ 127  ​		无符号数的表示范围应该是无异议的，但是有符号数的表示范围就有门道了，为什么负数会多表示一位呢？','# 十、二、八、十六进制间转换（包含负数间进制转换）原码、补码、反码定义\n\n### 0.0、有符号的 1 字节表示范围。 \n\n​		我们知道 1字节 (byte) = 8 位(bit)（即8位二进制，如：11111111）、1024个字节 = 1 K 、1024 K = 1M\n\n​		所以，一字节可以表示的范围就有 0 ~ 256 （无符号数），而有符号数表示的范围则是： -128 ~ 127\n\n​		无符号数的表示范围应该是无异议的，但是有符号数的表示范围就有门道了，为什么负数会多表示一位呢？\n\n​		正常来讲，1 字节有八位，其中最左位表示正负（0为正，1为负）其余七位表示范围，所以正的最大数为：01111111（二进制） = 127（十进制）后面二进制和十进制的表示方法使用 二进制：0bxxxxxxxx（x为 1或者0），十进制：xxx\n\n==所以理所当然的 （表示正数时）0b00000000 表示 0，那么 （表示负数时）0b10000000 又表示多少呢？总不能也表示 0 吧，所以，理所当然的 0b10000000 就表示 -128 、这也就是为什么负数有第128位的原因。==\n\n\n\n### 1.0、正数进制转换\n\n​		正常间的进制转换规则：\n\n先由十进制 转换为 二进制、然后 二进制 三位为一位的转换为 八进制 /或者四位为一位的转换为 十六进制。\n\n例：\n\n#### 1.1.1、十进制 10 转换为 二进制：\n\n​			10 除以 2 = 5 余数为 0；\n\n然后      5  除以 2 = 2 余数为 1；\n\n​              2  除以 2 = 1 余数为 0；\n\n​              1  除以 2 = 0 余数为 1；\n\n直到结果为0时，从低至高的获取余数、即 10 的二进制为：1010\n\n#### 1.1.2、二进制 1010 转换为 十进制\n\n1010 \n\n= 1 * 2的三次方 + 0 * 2的2次方 + 1 * 2的1次方 + 0 * 2的0次方\n\n= 8 + 0 + 2 + 0\n\n= 10\n\n#### 1.2.1二进制 1010 转换为 八进制：\n\n三位二进制为一位八进制、即利用二进制转为十进制的方法去三位合并为一位。\n\n例：\n\n1010（二进制）\n\n= 001 010 （因为原来为四位，可适当在最左添加 0 更好计算且不影响结果）\n\n= 1      2\n\n=12（八进制）\n\n所以二进制 1010 的 八进制 为 12\n\n同理、八 转 二 为：\n\n12\n\n= 1     2\n\n又因为 1 的二进制为 001 、2 的 二进制 为 010 （保持三位为一个单位）\n\n所以 = 001010 = 1010（二进制）\n\n\n\n#### 1.3.1 二进制 变为 十六进制\n\n同理 二进制 变 八进制，但是以 4 位为一个单位。\n\n即：\n\n1010 = A （十六进制）（0~9 然后是 A~F，A相当于 10 、F 相当于 15）\n\n同理，十六进制 变 二进制 略；\n\n\n\n### 2.1、负数的进制转换\n\n==定基调：负数在计算机中以补码形式存在！==\n\n所以就要搞清楚什么是补码以及怎么得到补码？\n\n首先，分为：原码、反码、补码、三种\n\n\n\n#### 2.1.1、原码是什么？\n\n​		是机器数中最简单的一种表示形式，其符号位为 0 表示正数， 符号位为 1 表示负数，数值位即真值的绝对值。\n\n例：\n\n+3 （十进制）的原码：\n\n= 00000011 （二进制）\n\n-3 的原码：\n\n= 10000011\n\n#### 2.1.3、补码是什么？\n\n​		日常生活中会遇到补数这个概念、如时钟里、3 和 15 都可以表示下午三点，为什么呢？\n\n​		假设现在时针指向 12 点、那么为使时针指向 3 点，则有两种方法：1、顺时针旋转分针 3 圈（一圈一小时）。2、逆时针旋转分针 9  圈 这两种方法的结果是一致的。假设顺时针为正、逆时针为负。那么 12 + 3 = 15（顺时针）、12 - 9 = 3（逆时针），由于时针转一圈12个小时相当于没有旋转、即 15 - 12 = 3 ，故 15 点和 3 点皆表示下午 3 点！这样 -3 和 +9 对时钟而言作用是一致的，又因为时钟 12 为一圈，是故：称之为 +9 是 -3 以 12 为模的补数。（参考自：北京理工大学出版社的计算机组成原理（潘雪峰 、、、著）P15页） \n\n​		沿用自计算机就出现了补码这一概念。\n\n##### 2.1.3.1、整数补码的定义\n\n首先、正数的补码与原码数值相同。\n\n其次、以 -3 为例，有两种定义方法\n\n1、将 +3 的原码表示，==包括符号位==在内各位取反，再在最低位上加 1\n\n例：\n\n00000011（+3原码）\n\n=11111100 + 1\n\n=11111101\n\n2、将 -3 的原码表示、不包括符号位各位取反，再在最低位上加 1\n\n例：\n\n10000011（-3原码）\n\n=11111100 + 1\n\n=11111101\n\n\n\n### 2.1.2、反码\n\n如果为正数，则与原码相同，如：+3的反码为：00000011\n\n==如果为负数、则是取原码的绝对值，然后按位取反（包括符号位）==，如：\n\n-3 的反码：\n\n-3 的原码：10000011\n\n取绝对值：00000011\n\n按位取反：11111100\n\n\n\n### 2.2、利用补码进行负数间的进制转换\n\n​		负数转换为二进制的补码，即代表负数的十进制转换为了二进制数。\n\n那么二进制表示的补码又可以通过三位表示一位的方法转换为八进制（符号位也进行计算），四位表示一位转换为16进制。\n\n例：\n\n#### 2.2.1、-10（十进制）转换为二进制\n\n-10 变为 有符号的二进制为：\n\n10001010（此时为原码）\n\n那么通过上面两种原码转换为补码的方法转换成补码：\n\n11110101 + 1\n\n=11110110（这个就是 -10 的二进制表示）\n\n额，二进制转换为十进制就是逆转步骤。\n\n\n\n#### 2.2.2、负数转换为八、十六进制\n\n以 -10 为例，先转换为二进制：11110110\n\n然后三位为一位转换为八进制：011 110 110\n\n= 366（八进制）\n\n然后四位为一位转换为十六进制：1111 0110\n\n= F6（十六进制）',1,1,99,'2022-11-26 02:49:50','',33333,0,''),(12,'String字符串浅析','首先，由 String 源码我们可以知道：  1. ~~String 类是被 final 修饰，即 String 字符串一旦被创建就无法被修改了。~~  2. String 类的底层就是 char[] 数组。  > **注意：String不可变原因不是因为value字符数组被 final 修饰！！！**  ​		即，==被 final 修饰的是 value 这个变量，关被 value 指向的数组空间什么事==  ​		我们无法修改 value 这个变量指向的地址，但是可以**修改指向地址空间里面的值**！','# String字符串浅析\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n    ...\n}\n```\n\n首先，由 String 源码我们可以知道：\n\n1. ~~String 类是被 final 修饰，即 String 字符串一旦被创建就无法被修改了。~~ \n2. String 类的底层就是 char[] 数组。\n\n> **注意：String不可变原因不是因为value字符数组被 final 修饰！！！**\n\n​		即，==被 final 修饰的是 value 这个变量，关被 value 指向的数组空间什么事==\n\n​		我们无法修改 value 这个变量指向的地址，但是可以**修改指向地址空间里面的值**！\n\n```java\npublic final class String implements java.io.Serializable, Comparable<String>, CharSequence {\n    private final char value[];\n	//...\n}\n```\n\n**真正不可变原因：**\n\n- **String 类中没有暴露任何可供修改类中 ==内部成员字段== 的方法。**\n- **String 整个类是被 final 修饰的，所以杜绝子类去更改 String 类的东西（==不能被继承==）**\n- **对于存储字符串的字符数组 value 使用 private 和 final 修饰，==防止 value 指向的地址发生改变==**\n\n\n\n\n那么、我们平常是怎么能够对字符串进行修改的呢？\n\n实际上，String 类型的变量被创建后，其 值 是存储在 String常量池中的，然后 变量 存储的是指向这个 值的地址，那么当我们修改字符串变量的值时，实际上是修改了变量指向的地址，具体实现是：\n\n```java\nString str = a;\n```\n\n在 栈中存放着一个String类型的变量 str ，str 会指向堆中的String常量池中的一块地址，这块地址存放着字符串 a。 \n\n当我们要将str的值修改为 b 时，即\n\n```java\nstr = b;\n```\n\n此时、因为String类型变量的值被创建了就无法被修改，所以 JVM虚拟机 会先在常量池中寻找是否有值 b，如果有，则是将栈中的字符串变量 str 由指向 a 的地址，转变为指向 b 的地址，以达到所谓重新赋值为b的效果，如果在常量池中没有找到 b 则会在常量池中新开辟一块空间来存放 b 值，同时将 str 从值向a的地址转换为指向 b 的地址，以此达到赋值的目的。\n\n一般，如果出现了下面这种情况：\n\n```java\nString str=\"\";\nfor(int i=0;i<10000;i++){\n    str +=\"hello\";\n}\n```\n\n执行过程将是，提取 hello并与str字符串合并后再在常量池中开辟新的空间存储合并后的字面常量，所以循环下来，会开辟10000个空间来存储，这样做极大的浪费了内存空间，所以就出现了：StringBuffer以及StringBuilder\n\nStringBuilder又称之为可变字符序列，可以看做是String的字符缓冲区，相当于一个容器，这个容器可以存储多个字符串，并且能够对其中的字符串进行各种操作。\n\n再来看看下面代码，\n\n```java\nStringBuilder str = new StringBuilder();\nfor(int i=0;i<10000;i++){\n   str.append(\"hello\"); // 将hello添加到字符串末尾。\n}\n```\n\n执行过程是，只new了一个对象，开辟了一次空间，每次新增hello时，都是直接在原有的基础上添加hello，这样极大的节省了空间。\n\n那已经有了StringBuilder为什么还要StringBuffer呢？四个字，线程安全\n\n从两者源码分析：\n\nStringBuffer:\n\n```java\npublic synchronized StringBuffer append(StringBuffer sb) {\n        toStringCache = null;\n        super.append(sb);\n        return this;\n    }\n\n```\n\nStringBuilder:\n\n```java\n @Override\n    public StringBuilder append(String str) {\n        super.append(str);\n        return this;\n    }\n```\n\n\n\n可以看到差别，StringBuffer方法上添加了锁关键字，synchronized，这个关键字可以在多线程访问是起到线程安全的作用，也就是说**StringBuffer是线程安全的**，这也是两者的区别。\n\n\n\n那为什么 StringBuilder会有线程安全问题呢？\n\n我们首先利用多线程去操作 StringBuilder类型的变量看看为什么会不安全：\n\n```java\npublic class MyTest  {\n    public static void main(String[] args) {\n        StringBuilder str = new StringBuilder();\n        for (int i = 0; i < 10; i++) {  // 开启10个线程\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    for (int i1 = 0; i1 < 100; i1++) {\n                        str.append(\"a\");  // 每个线程执行100添加字符串a的方法。\n                    }\n                }\n            }).start();\n        }\n        System.out.println(str.length());\n    }\n}\n```\n\n结果：在不开启sleep线程睡眠的情况下字符串长度显示只有 286，什么意思？\n\n按照理论上应该长度为1000，那是哪里出了问题呢\n\n我们可以看看 StringBuilder类的源码，\n\n```java\npublic final class StringBuilder\n    extends AbstractStringBuilder\n    implements java.io.Serializable, CharSequence\n{\n。。。\n}\n```\n\n可以看到，StringBuilder类继承自AbstractStringBuilder类，然后AbstractStringBuilder类中也有一个append()添加方法：\n\n```java\npublic AbstractStringBuilder append(StringBuffer sb) {\n        if (sb == null)\n            return appendNull();\n        int len = sb.length();\n        ensureCapacityInternal(count + len);\n        sb.getChars(0, len, value, count);\n        count += len;\n        return this;\n    }\n```\n\n可以看到，与返回字符串长度有关的变量分别是，len 与 count，那到底是具体哪一个呢，\n\n我们又知道，在方法中定义的变量，其生存周期一定是与方法一样，方法被调用结束，方法中定义的变量也就结束了。所以不存在其他线程能作用到此变量的情况，也就是说最有可能出错在 count 这个变量上，因为它属于成员变量。被所有线程共享，那么极有可能被两个线程同时作用导致出现线程安全的问题，解决方法也很简单，在方法上加，锁关键字 synchronized  ，这也就是为什么要 StringBuffer这个类的原因，能够保证线程安全。\n\n附：下面两个有什么区别\n\n```java\nString str = \"a\";\nString str = new String(\"a\");\n```\n\n​	在这之前，要搞清楚一个概念，在class文件中有一部分 来存储编译期间生成的 字面常量以及符号引用，这部分叫做class文件常量池，在运行期间对应着方法区的运行时常量池。\n\n​	当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。\n\n符号引用：即，我们写类之前用import 调用的其他API java.util.Date。\n\n​	言归正传，所以==str = \"a\"== 属于字面常量，在编译期间就已经生成了字面常量\"a\"和String类的符号引用，然后\"a\"被保存在运行时常量池中，之后，str变量在JVM的帮助下去寻找到了\"a\"并执行其地址\n\n但是 ==str1 = new String(\"a\")== 是先在堆中new出对象，然后在运行构造方法时会先在常量池中检查是否有这个值 \"a\" 如果有则将值 “a” 从常量池中复制一份到new出来的空间里进行存放，如果没有则是在常量池中先创建然后再复制。\n	\n所以、实际上所有的类实例化后，即在堆中new出一片空间后，是直接存放类中定义的变量的值的。而不是所谓的地址。\n\n   ==所以、str 存储的是字符串在常量池中的地址、而 str1 存储的是在堆中的地址，这也就是为什么两者用 = = 比较时为 false 的原因。==\n\n​	这里又衍生出了两个创建字符串的时机，一个是作为字面常量，在编译期间就产生了，一个是作为类进行加载然后再产生。\n\n​	**==只要是在两个不同时机产生的字符串，即使值相同，但是用= =号判断时就是为false==**\n\n注：被final修饰的也会在编译期产生。',0,1,0,'2022-11-27 01:39:48','0000-00-00',0,0,'无'),(13,'String字符串浅析','首先，由 String 源码我们可以知道：  1. ~~String 类是被 final 修饰，即 String 字符串一旦被创建就无法被修改了。~~  2. String 类的底层就是 char[] 数组。  > **注意：String不可变原因不是因为value字符数组被 final 修饰！！！**  ​		即，==被 final 修饰的是 value 这个变量，关被 value 指向的数组空间什么事==  ​		我们无法修改 value 这个变量指向的地址，但是可以**修改指向地址空间里面的值**！','# String字符串浅析\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n    ...\n}\n```\n\n首先，由 String 源码我们可以知道：\n\n1. ~~String 类是被 final 修饰，即 String 字符串一旦被创建就无法被修改了。~~ \n2. String 类的底层就是 char[] 数组。\n\n> **注意：String不可变原因不是因为value字符数组被 final 修饰！！！**\n\n​		即，==被 final 修饰的是 value 这个变量，关被 value 指向的数组空间什么事==\n\n​		我们无法修改 value 这个变量指向的地址，但是可以**修改指向地址空间里面的值**！\n\n```java\npublic final class String implements java.io.Serializable, Comparable<String>, CharSequence {\n    private final char value[];\n	//...\n}\n```\n\n**真正不可变原因：**\n\n- **String 类中没有暴露任何可供修改类中 ==内部成员字段== 的方法。**\n- **String 整个类是被 final 修饰的，所以杜绝子类去更改 String 类的东西（==不能被继承==）**\n- **对于存储字符串的字符数组 value 使用 private 和 final 修饰，==防止 value 指向的地址发生改变==**\n\n\n\n\n那么、我们平常是怎么能够对字符串进行修改的呢？\n\n实际上，String 类型的变量被创建后，其 值 是存储在 String常量池中的，然后 变量 存储的是指向这个 值的地址，那么当我们修改字符串变量的值时，实际上是修改了变量指向的地址，具体实现是：\n\n```java\nString str = a;\n```\n\n在 栈中存放着一个String类型的变量 str ，str 会指向堆中的String常量池中的一块地址，这块地址存放着字符串 a。 \n\n当我们要将str的值修改为 b 时，即\n\n```java\nstr = b;\n```\n\n此时、因为String类型变量的值被创建了就无法被修改，所以 JVM虚拟机 会先在常量池中寻找是否有值 b，如果有，则是将栈中的字符串变量 str 由指向 a 的地址，转变为指向 b 的地址，以达到所谓重新赋值为b的效果，如果在常量池中没有找到 b 则会在常量池中新开辟一块空间来存放 b 值，同时将 str 从值向a的地址转换为指向 b 的地址，以此达到赋值的目的。\n\n一般，如果出现了下面这种情况：\n\n```java\nString str=\"\";\nfor(int i=0;i<10000;i++){\n    str +=\"hello\";\n}\n```\n\n执行过程将是，提取 hello并与str字符串合并后再在常量池中开辟新的空间存储合并后的字面常量，所以循环下来，会开辟10000个空间来存储，这样做极大的浪费了内存空间，所以就出现了：StringBuffer以及StringBuilder\n\nStringBuilder又称之为可变字符序列，可以看做是String的字符缓冲区，相当于一个容器，这个容器可以存储多个字符串，并且能够对其中的字符串进行各种操作。\n\n再来看看下面代码，\n\n```java\nStringBuilder str = new StringBuilder();\nfor(int i=0;i<10000;i++){\n   str.append(\"hello\"); // 将hello添加到字符串末尾。\n}\n```\n\n执行过程是，只new了一个对象，开辟了一次空间，每次新增hello时，都是直接在原有的基础上添加hello，这样极大的节省了空间。\n\n那已经有了StringBuilder为什么还要StringBuffer呢？四个字，线程安全\n\n从两者源码分析：\n\nStringBuffer:\n\n```java\npublic synchronized StringBuffer append(StringBuffer sb) {\n        toStringCache = null;\n        super.append(sb);\n        return this;\n    }\n\n```\n\nStringBuilder:\n\n```java\n @Override\n    public StringBuilder append(String str) {\n        super.append(str);\n        return this;\n    }\n```\n\n\n\n可以看到差别，StringBuffer方法上添加了锁关键字，synchronized，这个关键字可以在多线程访问是起到线程安全的作用，也就是说**StringBuffer是线程安全的**，这也是两者的区别。\n\n\n\n那为什么 StringBuilder会有线程安全问题呢？\n\n我们首先利用多线程去操作 StringBuilder类型的变量看看为什么会不安全：\n\n```java\npublic class MyTest  {\n    public static void main(String[] args) {\n        StringBuilder str = new StringBuilder();\n        for (int i = 0; i < 10; i++) {  // 开启10个线程\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    for (int i1 = 0; i1 < 100; i1++) {\n                        str.append(\"a\");  // 每个线程执行100添加字符串a的方法。\n                    }\n                }\n            }).start();\n        }\n        System.out.println(str.length());\n    }\n}\n```\n\n结果：在不开启sleep线程睡眠的情况下字符串长度显示只有 286，什么意思？\n\n按照理论上应该长度为1000，那是哪里出了问题呢\n\n我们可以看看 StringBuilder类的源码，\n\n```java\npublic final class StringBuilder\n    extends AbstractStringBuilder\n    implements java.io.Serializable, CharSequence\n{\n。。。\n}\n```\n\n可以看到，StringBuilder类继承自AbstractStringBuilder类，然后AbstractStringBuilder类中也有一个append()添加方法：\n\n```java\npublic AbstractStringBuilder append(StringBuffer sb) {\n        if (sb == null)\n            return appendNull();\n        int len = sb.length();\n        ensureCapacityInternal(count + len);\n        sb.getChars(0, len, value, count);\n        count += len;\n        return this;\n    }\n```\n\n可以看到，与返回字符串长度有关的变量分别是，len 与 count，那到底是具体哪一个呢，\n\n我们又知道，在方法中定义的变量，其生存周期一定是与方法一样，方法被调用结束，方法中定义的变量也就结束了。所以不存在其他线程能作用到此变量的情况，也就是说最有可能出错在 count 这个变量上，因为它属于成员变量。被所有线程共享，那么极有可能被两个线程同时作用导致出现线程安全的问题，解决方法也很简单，在方法上加，锁关键字 synchronized  ，这也就是为什么要 StringBuffer这个类的原因，能够保证线程安全。\n\n附：下面两个有什么区别\n\n```java\nString str = \"a\";\nString str = new String(\"a\");\n```\n\n​	在这之前，要搞清楚一个概念，在class文件中有一部分 来存储编译期间生成的 字面常量以及符号引用，这部分叫做class文件常量池，在运行期间对应着方法区的运行时常量池。\n\n​	当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。\n\n符号引用：即，我们写类之前用import 调用的其他API java.util.Date。\n\n​	言归正传，所以==str = \"a\"== 属于字面常量，在编译期间就已经生成了字面常量\"a\"和String类的符号引用，然后\"a\"被保存在运行时常量池中，之后，str变量在JVM的帮助下去寻找到了\"a\"并执行其地址\n\n但是 ==str1 = new String(\"a\")== 是先在堆中new出对象，然后在运行构造方法时会先在常量池中检查是否有这个值 \"a\" 如果有则将值 “a” 从常量池中复制一份到new出来的空间里进行存放，如果没有则是在常量池中先创建然后再复制。\n	\n所以、实际上所有的类实例化后，即在堆中new出一片空间后，是直接存放类中定义的变量的值的。而不是所谓的地址。\n\n   ==所以、str 存储的是字符串在常量池中的地址、而 str1 存储的是在堆中的地址，这也就是为什么两者用 = = 比较时为 false 的原因。==\n\n​	这里又衍生出了两个创建字符串的时机，一个是作为字面常量，在编译期间就产生了，一个是作为类进行加载然后再产生。\n\n​	**==只要是在两个不同时机产生的字符串，即使值相同，但是用= =号判断时就是为false==**\n\n注：被final修饰的也会在编译期产生。',0,2,0,'2022-11-27 01:55:35','0000-00-00',0,0,'无'),(14,'String字符串浅析','首先，由 String 源码我们可以知道：  1. ~~String 类是被 final 修饰，即 String 字符串一旦被创建就无法被修改了。~~  2. String 类的底层就是 char[] 数组。  > **注意：String不可变原因不是因为value字符数组被 final 修饰！！！**  ​		即，==被 final 修饰的是 value 这个变量，关被 value 指向的数组空间什么事==  ​		我们无法修改 value 这个变量指向的地址，但是可以**修改指向地址空间里面的值**！','# String字符串浅析\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n    ...\n}\n```\n\n首先，由 String 源码我们可以知道：\n\n1. ~~String 类是被 final 修饰，即 String 字符串一旦被创建就无法被修改了。~~ \n2. String 类的底层就是 char[] 数组。\n\n> **注意：String不可变原因不是因为value字符数组被 final 修饰！！！**\n\n​		即，==被 final 修饰的是 value 这个变量，关被 value 指向的数组空间什么事==\n\n​		我们无法修改 value 这个变量指向的地址，但是可以**修改指向地址空间里面的值**！\n\n```java\npublic final class String implements java.io.Serializable, Comparable<String>, CharSequence {\n    private final char value[];\n	//...\n}\n```\n\n**真正不可变原因：**\n\n- **String 类中没有暴露任何可供修改类中 ==内部成员字段== 的方法。**\n- **String 整个类是被 final 修饰的，所以杜绝子类去更改 String 类的东西（==不能被继承==）**\n- **对于存储字符串的字符数组 value 使用 private 和 final 修饰，==防止 value 指向的地址发生改变==**\n\n\n\n\n那么、我们平常是怎么能够对字符串进行修改的呢？\n\n实际上，String 类型的变量被创建后，其 值 是存储在 String常量池中的，然后 变量 存储的是指向这个 值的地址，那么当我们修改字符串变量的值时，实际上是修改了变量指向的地址，具体实现是：\n\n```java\nString str = a;\n```\n\n在 栈中存放着一个String类型的变量 str ，str 会指向堆中的String常量池中的一块地址，这块地址存放着字符串 a。 \n\n当我们要将str的值修改为 b 时，即\n\n```java\nstr = b;\n```\n\n此时、因为String类型变量的值被创建了就无法被修改，所以 JVM虚拟机 会先在常量池中寻找是否有值 b，如果有，则是将栈中的字符串变量 str 由指向 a 的地址，转变为指向 b 的地址，以达到所谓重新赋值为b的效果，如果在常量池中没有找到 b 则会在常量池中新开辟一块空间来存放 b 值，同时将 str 从值向a的地址转换为指向 b 的地址，以此达到赋值的目的。\n\n一般，如果出现了下面这种情况：\n\n```java\nString str=\"\";\nfor(int i=0;i<10000;i++){\n    str +=\"hello\";\n}\n```\n\n执行过程将是，提取 hello并与str字符串合并后再在常量池中开辟新的空间存储合并后的字面常量，所以循环下来，会开辟10000个空间来存储，这样做极大的浪费了内存空间，所以就出现了：StringBuffer以及StringBuilder\n\nStringBuilder又称之为可变字符序列，可以看做是String的字符缓冲区，相当于一个容器，这个容器可以存储多个字符串，并且能够对其中的字符串进行各种操作。\n\n再来看看下面代码，\n\n```java\nStringBuilder str = new StringBuilder();\nfor(int i=0;i<10000;i++){\n   str.append(\"hello\"); // 将hello添加到字符串末尾。\n}\n```\n\n执行过程是，只new了一个对象，开辟了一次空间，每次新增hello时，都是直接在原有的基础上添加hello，这样极大的节省了空间。\n\n那已经有了StringBuilder为什么还要StringBuffer呢？四个字，线程安全\n\n从两者源码分析：\n\nStringBuffer:\n\n```java\npublic synchronized StringBuffer append(StringBuffer sb) {\n        toStringCache = null;\n        super.append(sb);\n        return this;\n    }\n\n```\n\nStringBuilder:\n\n```java\n @Override\n    public StringBuilder append(String str) {\n        super.append(str);\n        return this;\n    }\n```\n\n\n\n可以看到差别，StringBuffer方法上添加了锁关键字，synchronized，这个关键字可以在多线程访问是起到线程安全的作用，也就是说**StringBuffer是线程安全的**，这也是两者的区别。\n\n\n\n那为什么 StringBuilder会有线程安全问题呢？\n\n我们首先利用多线程去操作 StringBuilder类型的变量看看为什么会不安全：\n\n```java\npublic class MyTest  {\n    public static void main(String[] args) {\n        StringBuilder str = new StringBuilder();\n        for (int i = 0; i < 10; i++) {  // 开启10个线程\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    for (int i1 = 0; i1 < 100; i1++) {\n                        str.append(\"a\");  // 每个线程执行100添加字符串a的方法。\n                    }\n                }\n            }).start();\n        }\n        System.out.println(str.length());\n    }\n}\n```\n\n结果：在不开启sleep线程睡眠的情况下字符串长度显示只有 286，什么意思？\n\n按照理论上应该长度为1000，那是哪里出了问题呢\n\n我们可以看看 StringBuilder类的源码，\n\n```java\npublic final class StringBuilder\n    extends AbstractStringBuilder\n    implements java.io.Serializable, CharSequence\n{\n。。。\n}\n```\n\n可以看到，StringBuilder类继承自AbstractStringBuilder类，然后AbstractStringBuilder类中也有一个append()添加方法：\n\n```java\npublic AbstractStringBuilder append(StringBuffer sb) {\n        if (sb == null)\n            return appendNull();\n        int len = sb.length();\n        ensureCapacityInternal(count + len);\n        sb.getChars(0, len, value, count);\n        count += len;\n        return this;\n    }\n```\n\n可以看到，与返回字符串长度有关的变量分别是，len 与 count，那到底是具体哪一个呢，\n\n我们又知道，在方法中定义的变量，其生存周期一定是与方法一样，方法被调用结束，方法中定义的变量也就结束了。所以不存在其他线程能作用到此变量的情况，也就是说最有可能出错在 count 这个变量上，因为它属于成员变量。被所有线程共享，那么极有可能被两个线程同时作用导致出现线程安全的问题，解决方法也很简单，在方法上加，锁关键字 synchronized  ，这也就是为什么要 StringBuffer这个类的原因，能够保证线程安全。\n\n附：下面两个有什么区别\n\n```java\nString str = \"a\";\nString str = new String(\"a\");\n```\n\n​	在这之前，要搞清楚一个概念，在class文件中有一部分 来存储编译期间生成的 字面常量以及符号引用，这部分叫做class文件常量池，在运行期间对应着方法区的运行时常量池。\n\n​	当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。\n\n符号引用：即，我们写类之前用import 调用的其他API java.util.Date。\n\n​	言归正传，所以==str = \"a\"== 属于字面常量，在编译期间就已经生成了字面常量\"a\"和String类的符号引用，然后\"a\"被保存在运行时常量池中，之后，str变量在JVM的帮助下去寻找到了\"a\"并执行其地址\n\n但是 ==str1 = new String(\"a\")== 是先在堆中new出对象，然后在运行构造方法时会先在常量池中检查是否有这个值 \"a\" 如果有则将值 “a” 从常量池中复制一份到new出来的空间里进行存放，如果没有则是在常量池中先创建然后再复制。\n	\n所以、实际上所有的类实例化后，即在堆中new出一片空间后，是直接存放类中定义的变量的值的。而不是所谓的地址。\n\n   ==所以、str 存储的是字符串在常量池中的地址、而 str1 存储的是在堆中的地址，这也就是为什么两者用 = = 比较时为 false 的原因。==\n\n​	这里又衍生出了两个创建字符串的时机，一个是作为字面常量，在编译期间就产生了，一个是作为类进行加载然后再产生。\n\n​	**==只要是在两个不同时机产生的字符串，即使值相同，但是用= =号判断时就是为false==**\n\n注：被final修饰的也会在编译期产生。',0,1,0,'2022-11-27 01:56:42','0000-00-00',0,0,'无'),(15,'String字符串浅析','首先，由 String 源码我们可以知道：  1. ~~String 类是被 final 修饰，即 String 字符串一旦被创建就无法被修改了。~~  2. String 类的底层就是 char[] 数组。  > **注意：String不可变原因不是因为value字符数组被 final 修饰！！！**  ​		即，==被 final 修饰的是 value 这个变量，关被 value 指向的数组空间什么事==  ​		我们无法修改 value 这个变量指向的地址，但是可以**修改指向地址空间里面的值**！','# String字符串浅析\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n    ...\n}\n```\n\n首先，由 String 源码我们可以知道：\n\n1. ~~String 类是被 final 修饰，即 String 字符串一旦被创建就无法被修改了。~~ \n2. String 类的底层就是 char[] 数组。\n\n> **注意：String不可变原因不是因为value字符数组被 final 修饰！！！**\n\n​		即，==被 final 修饰的是 value 这个变量，关被 value 指向的数组空间什么事==\n\n​		我们无法修改 value 这个变量指向的地址，但是可以**修改指向地址空间里面的值**！\n\n```java\npublic final class String implements java.io.Serializable, Comparable<String>, CharSequence {\n    private final char value[];\n	//...\n}\n```\n\n**真正不可变原因：**\n\n- **String 类中没有暴露任何可供修改类中 ==内部成员字段== 的方法。**\n- **String 整个类是被 final 修饰的，所以杜绝子类去更改 String 类的东西（==不能被继承==）**\n- **对于存储字符串的字符数组 value 使用 private 和 final 修饰，==防止 value 指向的地址发生改变==**\n\n\n\n\n那么、我们平常是怎么能够对字符串进行修改的呢？\n\n实际上，String 类型的变量被创建后，其 值 是存储在 String常量池中的，然后 变量 存储的是指向这个 值的地址，那么当我们修改字符串变量的值时，实际上是修改了变量指向的地址，具体实现是：\n\n```java\nString str = a;\n```\n\n在 栈中存放着一个String类型的变量 str ，str 会指向堆中的String常量池中的一块地址，这块地址存放着字符串 a。 \n\n当我们要将str的值修改为 b 时，即\n\n```java\nstr = b;\n```\n\n此时、因为String类型变量的值被创建了就无法被修改，所以 JVM虚拟机 会先在常量池中寻找是否有值 b，如果有，则是将栈中的字符串变量 str 由指向 a 的地址，转变为指向 b 的地址，以达到所谓重新赋值为b的效果，如果在常量池中没有找到 b 则会在常量池中新开辟一块空间来存放 b 值，同时将 str 从值向a的地址转换为指向 b 的地址，以此达到赋值的目的。\n\n一般，如果出现了下面这种情况：\n\n```java\nString str=\"\";\nfor(int i=0;i<10000;i++){\n    str +=\"hello\";\n}\n```\n\n执行过程将是，提取 hello并与str字符串合并后再在常量池中开辟新的空间存储合并后的字面常量，所以循环下来，会开辟10000个空间来存储，这样做极大的浪费了内存空间，所以就出现了：StringBuffer以及StringBuilder\n\nStringBuilder又称之为可变字符序列，可以看做是String的字符缓冲区，相当于一个容器，这个容器可以存储多个字符串，并且能够对其中的字符串进行各种操作。\n\n再来看看下面代码，\n\n```java\nStringBuilder str = new StringBuilder();\nfor(int i=0;i<10000;i++){\n   str.append(\"hello\"); // 将hello添加到字符串末尾。\n}\n```\n\n执行过程是，只new了一个对象，开辟了一次空间，每次新增hello时，都是直接在原有的基础上添加hello，这样极大的节省了空间。\n\n那已经有了StringBuilder为什么还要StringBuffer呢？四个字，线程安全\n\n从两者源码分析：\n\nStringBuffer:\n\n```java\npublic synchronized StringBuffer append(StringBuffer sb) {\n        toStringCache = null;\n        super.append(sb);\n        return this;\n    }\n\n```\n\nStringBuilder:\n\n```java\n @Override\n    public StringBuilder append(String str) {\n        super.append(str);\n        return this;\n    }\n```\n\n\n\n可以看到差别，StringBuffer方法上添加了锁关键字，synchronized，这个关键字可以在多线程访问是起到线程安全的作用，也就是说**StringBuffer是线程安全的**，这也是两者的区别。\n\n\n\n那为什么 StringBuilder会有线程安全问题呢？\n\n我们首先利用多线程去操作 StringBuilder类型的变量看看为什么会不安全：\n\n```java\npublic class MyTest  {\n    public static void main(String[] args) {\n        StringBuilder str = new StringBuilder();\n        for (int i = 0; i < 10; i++) {  // 开启10个线程\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    for (int i1 = 0; i1 < 100; i1++) {\n                        str.append(\"a\");  // 每个线程执行100添加字符串a的方法。\n                    }\n                }\n            }).start();\n        }\n        System.out.println(str.length());\n    }\n}\n```\n\n结果：在不开启sleep线程睡眠的情况下字符串长度显示只有 286，什么意思？\n\n按照理论上应该长度为1000，那是哪里出了问题呢\n\n我们可以看看 StringBuilder类的源码，\n\n```java\npublic final class StringBuilder\n    extends AbstractStringBuilder\n    implements java.io.Serializable, CharSequence\n{\n。。。\n}\n```\n\n可以看到，StringBuilder类继承自AbstractStringBuilder类，然后AbstractStringBuilder类中也有一个append()添加方法：\n\n```java\npublic AbstractStringBuilder append(StringBuffer sb) {\n        if (sb == null)\n            return appendNull();\n        int len = sb.length();\n        ensureCapacityInternal(count + len);\n        sb.getChars(0, len, value, count);\n        count += len;\n        return this;\n    }\n```\n\n可以看到，与返回字符串长度有关的变量分别是，len 与 count，那到底是具体哪一个呢，\n\n我们又知道，在方法中定义的变量，其生存周期一定是与方法一样，方法被调用结束，方法中定义的变量也就结束了。所以不存在其他线程能作用到此变量的情况，也就是说最有可能出错在 count 这个变量上，因为它属于成员变量。被所有线程共享，那么极有可能被两个线程同时作用导致出现线程安全的问题，解决方法也很简单，在方法上加，锁关键字 synchronized  ，这也就是为什么要 StringBuffer这个类的原因，能够保证线程安全。\n\n附：下面两个有什么区别\n\n```java\nString str = \"a\";\nString str = new String(\"a\");\n```\n\n​	在这之前，要搞清楚一个概念，在class文件中有一部分 来存储编译期间生成的 字面常量以及符号引用，这部分叫做class文件常量池，在运行期间对应着方法区的运行时常量池。\n\n​	当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。\n\n符号引用：即，我们写类之前用import 调用的其他API java.util.Date。\n\n​	言归正传，所以==str = \"a\"== 属于字面常量，在编译期间就已经生成了字面常量\"a\"和String类的符号引用，然后\"a\"被保存在运行时常量池中，之后，str变量在JVM的帮助下去寻找到了\"a\"并执行其地址\n\n但是 ==str1 = new String(\"a\")== 是先在堆中new出对象，然后在运行构造方法时会先在常量池中检查是否有这个值 \"a\" 如果有则将值 “a” 从常量池中复制一份到new出来的空间里进行存放，如果没有则是在常量池中先创建然后再复制。\n	\n所以、实际上所有的类实例化后，即在堆中new出一片空间后，是直接存放类中定义的变量的值的。而不是所谓的地址。\n\n   ==所以、str 存储的是字符串在常量池中的地址、而 str1 存储的是在堆中的地址，这也就是为什么两者用 = = 比较时为 false 的原因。==\n\n​	这里又衍生出了两个创建字符串的时机，一个是作为字面常量，在编译期间就产生了，一个是作为类进行加载然后再产生。\n\n​	**==只要是在两个不同时机产生的字符串，即使值相同，但是用= =号判断时就是为false==**\n\n注：被final修饰的也会在编译期产生。',0,2,0,'2022-11-27 01:56:55','0000-00-00',0,0,'无'),(16,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,1,0,'2022-11-28 02:24:09','0000-00-00',0,0,'无'),(17,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,2,0,'2022-11-28 02:24:12','0000-00-00',0,0,'无'),(18,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,1,0,'2022-11-28 02:24:15','0000-00-00',0,0,'无'),(19,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,2,0,'2022-11-28 02:24:16','0000-00-00',0,0,'无'),(20,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,1,0,'2022-11-28 02:24:17','0000-00-00',0,0,'无'),(21,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,2,0,'2022-11-28 02:24:19','0000-00-00',0,0,'无'),(22,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,1,0,'2022-11-28 02:24:21','0000-00-00',0,0,'无'),(23,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,2,0,'2022-11-28 02:24:22','0000-00-00',0,0,'无'),(25,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,1,0,'2022-11-28 02:24:27','0000-00-00',0,0,'无'),(26,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,2,0,'2022-11-28 02:24:28','0000-00-00',0,0,'无'),(27,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,1,0,'2022-11-28 02:24:29','0000-00-00',0,0,'无'),(28,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,2,0,'2022-11-28 02:24:31','0000-00-00',0,0,'无'),(29,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,2,0,'2022-11-28 02:24:32','0000-00-00',0,0,'无'),(30,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,1,0,'2022-11-28 02:24:34','0000-00-00',0,0,'无'),(31,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,2,0,'2022-11-28 02:24:35','0000-00-00',0,0,'无'),(32,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,1,0,'2022-11-28 02:24:41','0000-00-00',0,0,'无'),(33,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,0,0,'2022-11-28 02:24:43','0000-00-00',0,0,'无'),(34,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,2,0,'2022-11-28 02:24:44','0000-00-00',0,0,'无'),(35,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,2,0,'2022-11-28 02:24:46','0000-00-00',0,0,'无'),(36,'id>=#{paging}','id>=#{paging}','测试\nid>=#{paging}\nid>=#{paging}id>=#{paging}id>=#{paging}\nid>=#{paging}\nid>=#{paging}\n\nid>=#{paging}',1,2,0,'2022-11-28 02:24:47','0000-00-00',0,0,'无'),(37,'测试文章','测试文章','测试文章',5,0,0,'2022-11-29 04:20:58','0000-00-00',0,0,'无'),(38,'测试文章2','测试文章2','测试文章2',5,1,0,'2022-11-29 04:23:07','0000-00-00',0,0,'无'),(39,'测试文章3','测试文章3','测试文章2',5,2,0,'2022-11-29 04:24:07','0000-00-00',0,0,'无'),(40,'测试文章4','测试文章4','测试文章4',5,2,0,'2022-11-29 04:24:34','0000-00-00',0,0,'无'),(41,'测试文章root1','测试文章root1','测试文章root1',1,2,0,'2022-11-29 05:06:24','0000-00-00',0,0,'无');

/*Table structure for table `comment` */

DROP TABLE IF EXISTS `comment`;

CREATE TABLE `comment` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '评论id',
  `blog_id` int(10) NOT NULL DEFAULT '0' COMMENT '属于哪个博客',
  `level` int(4) NOT NULL DEFAULT '1' COMMENT '1:表示父级为博客，2：表示是评论下的评论(即回复)',
  `level2` int(4) NOT NULL DEFAULT '-1' COMMENT '默认为-1，如果是二级评论则记录父级评论id',
  `user_id` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '发布者id',
  `time` varchar(50) DEFAULT NULL COMMENT '发布时间',
  `content` tinytext COMMENT '评论内容',
  `audit` int(4) NOT NULL DEFAULT '2' COMMENT '审核状态（0(通过)、1(未通过)、2(未审核)',
  `like` int(10) NOT NULL DEFAULT '0' COMMENT '点赞数',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `comment` */

/*Table structure for table `tags` */

DROP TABLE IF EXISTS `tags`;

CREATE TABLE `tags` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '标签id',
  `tag` varchar(30) DEFAULT NULL COMMENT '标签名称',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `tags` */

/*Table structure for table `user` */

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '用户id',
  `name` varchar(100) NOT NULL COMMENT '用户名',
  `pwd` varchar(100) NOT NULL COMMENT '密码',
  `nickname` varchar(100) NOT NULL DEFAULT '普通用户' COMMENT '昵称',
  `root` int(4) unsigned NOT NULL DEFAULT '1' COMMENT '权限(0:管理员，1:普通用户)',
  `email` varchar(100) NOT NULL DEFAULT '0' COMMENT '邮箱',
  `head` varchar(200) DEFAULT '0' COMMENT '头像地址',
  `register_time` varchar(50) DEFAULT '0000-00-00' COMMENT '注册时间',
  `birthday` varchar(50) DEFAULT '0000-00-00' COMMENT '生日',
  `age` int(4) unsigned DEFAULT '18' COMMENT '年龄',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

/*Data for the table `user` */

insert  into `user`(`id`,`name`,`pwd`,`nickname`,`root`,`email`,`head`,`register_time`,`birthday`,`age`) values (1,'root','123456','管理员',0,'1160653906@qq.com','0','2022-10-02','2000-10-02',18),(2,'zou','123456','普通用户',1,'0','0','0000-00-00','0000-00-00',18),(3,'root1','1','普通用户',1,'0','0','2022-11-27 03:03:25','0000-00-00',18),(4,'zoufeiming','123456','普通用户',1,'0','0','2022-11-27 03:09:49','0000-00-00',18),(5,'zou1','123456','普通用户',1,'0','0','2022-11-29 04:18:23','0000-00-00',18);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
